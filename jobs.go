package main

import (
	"encoding/json"
	"log/slog"
	"net/http"
	"strconv"

	"github.com/go-chi/chi/v5"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/shv-ng/hirehustle/db"
)

// Request/Response structs (not generated by sqlc)
type CreateJobRequest struct {
	Company     string  `json:"company"`
	Role        string  `json:"role"`
	URL         string  `json:"url"`
	Description string  `json:"description"`
	Status      *string `json:"status"` // Pointer to handle null
}

type UpdateJobRequest struct {
	ID          int32   `json:"id"`
	Company     string  `json:"company"`
	Role        string  `json:"role"`
	URL         string  `json:"url"`
	Description string  `json:"description"`
	Status      *string `json:"status"`
}

func createJobHandler(queries *db.Queries) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		var req CreateJobRequest
		if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
			slog.Warn("Invalid request body", "error", err)
			http.Error(w, "Invalid request body", http.StatusBadRequest)
			return
		}

		// Convert to sqlc params
		params := db.CreateJobParams{
			Company:     req.Company,
			Role:        req.Role,
			Url:         pgtype.Text{String: req.URL, Valid: req.URL != ""},
			Description: pgtype.Text{String: req.Description, Valid: req.Description != ""},
		}

		// Handle status
		if req.Status != nil && *req.Status != "" {
			params.Status = db.NullJobstatus{
				Jobstatus: db.Jobstatus(*req.Status),
				Valid:     true,
			}
		} else {
			params.Status = db.NullJobstatus{
				Jobstatus: db.JobstatusWishlist,
				Valid:     true,
			}
		}

		job, err := queries.CreateJob(ctx, params)
		if err != nil {
			slog.Error("Failed to create job", "error", err)
			http.Error(w, "Failed to create job", http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(toJobResponse(job))
	}
}

func updateJobHandler(queries *db.Queries) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		idParam := chi.URLParam(r, "id")
		jobID, err := strconv.Atoi(idParam)
		if err != nil {
			slog.Warn("Invalid job ID", "jobID", idParam, "error", err)
			http.Error(w, "Job ID must be an integer", http.StatusBadRequest)
			return
		}

		var req UpdateJobRequest
		if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
			slog.Warn("Invalid request body", "error", err)
			http.Error(w, "Invalid request body", http.StatusBadRequest)
			return
		}

		params := db.UpdateJobParams{
			ID:          int32(jobID),
			Company:     req.Company,
			Role:        req.Role,
			Url:         pgtype.Text{String: req.URL, Valid: req.URL != ""},
			Description: pgtype.Text{String: req.Description, Valid: req.Description != ""},
		}

		if req.Status != nil && *req.Status != "" {
			params.Status = db.NullJobstatus{
				Jobstatus: db.Jobstatus(*req.Status),
				Valid:     true,
			}
		} else {
			params.Status = db.NullJobstatus{Valid: false}
		}

		job, err := queries.UpdateJob(ctx, params)
		if err != nil {
			slog.Error("Failed to update job", "error", err)
			http.Error(w, "Failed to update job", http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(toJobResponse(job))
	}
}

func listJobsHandler(queries *db.Queries) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		jobs, err := queries.ListJobs(ctx)
		if err != nil {
			slog.Error("Failed to list jobs", "error", err)
			http.Error(w, "Failed to list jobs", http.StatusInternalServerError)
			return
		}

		response := make([]JobResponse, len(jobs))
		for i, job := range jobs {
			response[i] = toJobResponse(job)
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(response)
	}
}

func getJobHandler(queries *db.Queries) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		idParam := chi.URLParam(r, "id")
		jobID, err := strconv.Atoi(idParam)
		if err != nil {
			slog.Warn("Invalid job ID", "jobID", idParam, "error", err)
			http.Error(w, "Job ID must be an integer", http.StatusBadRequest)
			return
		}

		job, err := queries.GetJob(ctx, int32(jobID))
		if err != nil {
			slog.Error("Failed to get job", "error", err)
			http.Error(w, "Failed to get job", http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(toJobResponse(job))
	}
}

func deleteJobHandler(queries *db.Queries) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		idParam := chi.URLParam(r, "id")
		jobID, err := strconv.Atoi(idParam)
		if err != nil {
			slog.Warn("Invalid job ID", "jobID", idParam, "error", err)
			http.Error(w, "Job ID must be an integer", http.StatusBadRequest)
			return
		}

		if err := queries.DeleteJob(ctx, int32(jobID)); err != nil {
			slog.Error("Failed to delete job", "error", err)
			http.Error(w, "Failed to delete job", http.StatusInternalServerError)
			return
		}

		w.WriteHeader(http.StatusNoContent)
	}
}

// Helper: Convert db.Job to JSON-friendly response
type JobResponse struct {
	ID          int32   `json:"id"`
	Company     string  `json:"company"`
	Role        string  `json:"role"`
	URL         string  `json:"url"`
	Description string  `json:"description"`
	Status      string  `json:"status"`
	CreatedAt   string  `json:"created_at"`
	AppliedAt   *string `json:"applied_at"`
}

func toJobResponse(job db.Job) JobResponse {
	resp := JobResponse{
		ID:          job.ID,
		Company:     job.Company,
		Role:        job.Role,
		URL:         job.Url.String,
		Description: job.Description.String,
		Status:      string(job.Status.Jobstatus),
	}

	if job.CreatedAt.Valid {
		resp.CreatedAt = job.CreatedAt.Time.Format("2006-01-02T15:04:05Z")
	}

	if job.AppliedAt.Valid {
		appliedAt := job.AppliedAt.Time.Format("2006-01-02T15:04:05Z")
		resp.AppliedAt = &appliedAt
	}

	return resp
}
